// Copyright 2021 The Wuffs Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// --------

// Filter 1: Sub.

// This (filter = 1, distance = 3) implementation doesn't actually bench faster
// than the non-SIMD one.
//
// pri func decoder.filter_1_distance_3_sse128!(curr: slice base.u8),
//     choose cpu_arch >= sse128,
// {
//     var c    : slice base.u8
//     var x128 : base.sse128_i
//     var a128 : base.sse128_i
//
//     iterate (c = args.curr)(length: 4, advance: 3, unroll: 1) {
//         x128.load_u32!(a: c.peek_u32le())
//         x128 = x128._mm_add_epi8!(b: a128)
//         a128 = x128
//         c.poke_u24le!(a: x128.truncate_u32())
//     } else (length: 3, advance: 3, unroll: 1) {
//         x128.load_u32!(a: c.peek_u24le_as_u32())
//         x128 = x128._mm_add_epi8!(b: a128)
//         c.poke_u24le!(a: x128.truncate_u32())
//     }
// }

pri func decoder.filter_1_distance_4_sse128!(curr: slice base.u8),
	choose cpu_arch >= sse128,
{
	var c    : slice base.u8
	var x128 : base.sse128_i
	var a128 : base.sse128_i

	iterate (c = args.curr)(length: 4, advance: 4, unroll: 1) {
		x128.load_u32!(a: c.peek_u32le())
		x128 = x128._mm_add_epi8!(b: a128)
		a128 = x128
		c.poke_u32le!(a: x128.truncate_u32())
	}
}
